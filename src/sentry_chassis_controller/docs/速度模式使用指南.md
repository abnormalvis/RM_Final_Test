# 速度模式使用指南

## 概述

参考 `hero_chassis_controller` 的实现，我们在 `wheel_pid_controller` 中添加了速度模式切换功能，支持两种坐标系下的速度控制：

1. **Local 模式（默认）**：速度相对于底盘坐标系 (`base_link`)
2. **Global 模式**：速度相对于世界坐标系 (`odom`)

## 实现原理

### Hero 实现参考

```cpp
// hero_chassis_controller.cpp 中的关键代码
if(speed_mode_=="global"){
    try{
        tf::TransformListener tf_listener;
        geometry_msgs::Vector3Stamped vel_local,vel_global;
        vel_global.header.frame_id="odom";
        vel_global.vector.x = vel.linear.x;
        vel_global.vector.y = vel.linear.y;
        vel_global.vector.z = 0.0;
        
        tf_listener.waitForTransform("base_link","odom",ros::Time(),ros::Duration(2.0));
        tf_listener.transformVector("base_link",vel_global,vel_local);
        
        vel.linear.x=vel_local.vector.x;
        vel.linear.y=vel_local.vector.y;
    }
    catch(tf::TransformException& ex){
        ROS_WARN("TF transform error: %s",ex.what());
        return;
    }
}
```

### 我们的实现

在 `wheel_pid_controller.cpp` 的 `cmdVelCallback()` 中：

```cpp
if (speed_mode_ == "global")
{
    // Transform velocity from global (odom) frame to local (base_link) frame
    try
    {
        geometry_msgs::Vector3Stamped vel_global, vel_local;
        vel_global.header.frame_id = odom_frame_;
        vel_global.vector.x = vx;
        vel_global.vector.y = vy;
        vel_global.vector.z = 0.0;

        // Wait for transform and convert (with timeout protection)
        tf_listener_.waitForTransform(base_link_frame_, odom_frame_, ros::Time(), ros::Duration(0.1));
        tf_listener_.transformVector(base_link_frame_, vel_global, vel_local);

        // Use transformed velocity
        vx = vel_local.vector.x;
        vy = vel_local.vector.y;
    }
    catch (tf::TransformException &ex)
    {
        ROS_WARN_THROTTLE(2.0, "TF transform error in global mode: %s", ex.what());
        // Fallback: use command as-is (assume local frame)
    }
}
```

## 配置方法

### 1. 修改 `wheel_pid_params.yaml`

```yaml
wheel_pid_controller:
  # Speed mode: "local" or "global"
  speed_mode: "local"  # 改为 "global" 启用全局模式
  
  # Frame IDs (需要与 TF 树一致)
  odom_frame: "odom"
  base_link_frame: "base_link"
```

### 2. 运行时动态切换（可选）

```bash
# 切换到 global 模式
rosparam set /wheel_pid_controller/speed_mode "global"

# 切换回 local 模式
rosparam set /wheel_pid_controller/speed_mode "local"

# 注意：需要重启控制器才能生效
rosservice call /controller_manager/reload_controller_libraries "{}"
```

## 使用场景

### Local 模式（推荐用于键盘控制）

**应用场景**：
- 键盘遥控（`sentry_control_key_feature`）
- 手动驾驶
- 摇杆控制
- 任何需要"相对底盘方向"运动的场景

**行为特性**：
- 按 W → 始终向底盘前方移动
- 按 A → 始终向底盘左侧移动
- 按 D → 始终向底盘右侧移动
- **不受底盘旋转影响**：即使底盘旋转，W 仍然是"前进"

**数学表示**：
```
cmd_vel 中的速度直接表示 base_link 坐标系下的速度
vx_base_link = cmd_vel.linear.x
vy_base_link = cmd_vel.linear.y
```

### Global 模式（推荐用于自主导航）

**应用场景**：
- 自主导航（`move_base`）
- 路径跟踪
- 全局路径规划
- 任何需要"相对世界方向"运动的场景

**行为特性**：
- 按 W → 向世界坐标系 X 轴正方向移动（无论底盘朝哪）
- 按 A → 向世界坐标系 Y 轴正方向移动
- 按 D → 向世界坐标系 Y 轴负方向移动
- **受底盘旋转影响**：底盘旋转后，需要调整各轮速度以保持世界方向不变

**数学表示**：
```
cmd_vel 中的速度表示 odom 坐标系下的速度
需要通过旋转矩阵转换到 base_link：

[vx_base]   [cos(θ)  sin(θ)] [vx_odom]
[vy_base] = [-sin(θ) cos(θ)] [vy_odom]

其中 θ 是底盘在 odom 中的航向角
```

## 对比示例

假设底盘当前航向角为 90°（向左转了 90°）：

### Local 模式
```bash
# 发布命令：向前（base_link 的 x 轴）
rostopic pub /cmd_vel geometry_msgs/Twist "linear: {x: 1.0, y: 0.0, z: 0.0}" -r 10

# 实际运动：沿着底盘当前朝向的方向（世界坐标系的 +Y 方向）
# 因为底盘已经向左转了 90°
```

### Global 模式
```bash
# 发布命令：向前（odom 的 x 轴）
rostopic pub /cmd_vel geometry_msgs/Twist "linear: {x: 1.0, y: 0.0, z: 0.0}" -r 10

# 实际运动：始终沿世界坐标系 +X 方向
# 控制器会自动调整轮速，使底盘横向移动以保持世界方向
```

## 键盘节点的速度模式

注意：`sentry_control_key_feature.cpp` 中也有自己的 `velocity_mode` 参数！

### 两层架构

```
键盘节点 (sentry_control_key_feature)
  ├─ velocity_mode: "global" or "chassis"
  ├─ 将键盘输入转换为速度命令
  └─ 发布到 /cmd_vel
       ↓
控制器 (wheel_pid_controller)
  ├─ speed_mode: "local" or "global"
  ├─ 接收 /cmd_vel
  └─ 控制轮子运动
```

### 推荐配置组合

| 键盘节点 velocity_mode | 控制器 speed_mode | 效果 | 推荐场景 |
|----------------------|------------------|------|---------|
| `"global"` | `"local"` | ✅ **推荐**：键盘节点做坐标转换，控制器直接使用 | 键盘控制 |
| `"chassis"` | `"local"` | ✅ 可用：双方都用底盘坐标 | 简单遥控 |
| `"global"` | `"global"` | ❌ 冲突：重复转换，错误 | 不推荐 |
| `"chassis"` | `"global"` | ❌ 混乱：语义不清 | 不推荐 |

**当前默认配置（推荐保持）**：
- 键盘节点：`velocity_mode: "global"`（在 `sentry_control_key_feature.cpp` 中）
- 控制器：`speed_mode: "local"`（在 `wheel_pid_params.yaml` 中）

这样键盘节点负责坐标转换，控制器只需要处理底盘坐标系的速度，职责清晰。

## 自主导航配置

如果将来使用 `move_base` 进行自主导航，推荐配置：

```yaml
# wheel_pid_params.yaml
wheel_pid_controller:
  speed_mode: "global"  # 让控制器处理全局速度

# move_base 配置
base_local_planner: "dwa_local_planner/DWAPlannerROS"
DWAPlannerROS:
  # move_base 会在 odom 坐标系下规划路径
  # 发布的 cmd_vel 也是 odom 坐标系
  global_frame_id: "odom"
  robot_base_frame: "base_link"
```

这样 `move_base` 发布的全局坐标系速度会被控制器正确转换。

## TF 依赖

**Global 模式需要 TF 树正常工作**：

```
odom
 └─ base_link
     └─ [其他关节]
```

检查 TF 是否正常：

```bash
# 查看 TF 树
rosrun tf view_frames
evince frames.pdf

# 实时监听 odom -> base_link 变换
rosrun tf tf_echo odom base_link

# 输出示例：
# At time 1234.567
# - Translation: [1.234, 0.567, 0.000]
# - Rotation: in Quaternion [0.000, 0.000, 0.707, 0.707]
#             in RPY (radian) [0.000, -0.000, 1.571]  # yaw = 90°
```

如果 TF 不可用，global 模式会自动降级到 local 模式（有警告）。

## 调试技巧

### 1. 查看当前模式

```bash
rosparam get /wheel_pid_controller/speed_mode
```

### 2. 监听调试日志

```bash
# 启用 DEBUG 级别日志
rosservice call /wheel_pid_controller/set_logger_level "logger: 'ros.sentry_chassis_controller'
level: 'debug'"

# 查看坐标转换信息
# 会每秒输出一次：Global mode: odom_vel(1.00,0.00) -> base_vel(0.71,0.71)
```

### 3. 可视化速度命令

```bash
# 订阅控制器接收到的速度（转换前）
rostopic echo /cmd_vel

# 订阅期望的轮速（转换后）
rostopic echo /desired_wheel_states
```

## 常见问题

### Q1: 为什么键盘控制没有按预期方向移动？

**A**: 检查两层速度模式配置：
1. 键盘节点的 `velocity_mode`（在启动时打印）
2. 控制器的 `speed_mode`（在 `rosparam` 中）

推荐配置：键盘 `"global"` + 控制器 `"local"`

### Q2: Global 模式下底盘不动或抖动？

**A**: 检查 TF 树：
```bash
rosrun tf tf_echo odom base_link
```
如果没有输出或报错，说明 TF 不可用，global 模式无法工作。

### Q3: 如何在运行时切换模式？

**A**: 修改参数后需要重启控制器（或整个仿真）：
```bash
# 方法 1：重启控制器
rosservice call /controller_manager/switch_controller "{start_controllers: [], stop_controllers: ['wheel_pid_controller'], strictness: 2}"
rosservice call /controller_manager/switch_controller "{start_controllers: ['wheel_pid_controller'], stop_controllers: [], strictness: 2}"

# 方法 2：重新启动整个仿真（更简单）
# Ctrl+C 终止，然后重新 roslaunch
```

### Q4: hero 的麦克纳姆轮和我们的舵轮有什么区别？

**A**: 
- **Hero（麦克纳姆轮）**：无需转向，直接通过4个轮速控制全向运动
  ```cpp
  // hero 的运动学（简单）
  front_left_vel_ = vx - vy - wz*r;
  front_right_vel_ = vx + vy + wz*r;
  back_left_vel_ = vx + vy - wz*r;
  back_right_vel_ = vx - vy + wz*r;
  ```

- **我们（舵轮）**：需要先计算舵角，再计算轮速（IK 更复杂）
  ```cpp
  // 我们的运动学（复杂）
  auto ik = sentry_kinematics::inverseKinematics(vx, vy, wz, ...);
  pivot_cmd_[i] = ik.steer_angle[i];   // 先转向
  wheel_cmd_[i] = ik.wheel_angular_vel[i];  // 再驱动
  ```

但速度模式转换的原理相同：都是通过 TF 将 odom 速度转换到 base_link。

## 总结

- ✅ **默认配置（local 模式）**：适合当前的键盘控制，无需修改
- ✅ **Global 模式**：将来自主导航时可以启用，需要确保 TF 正常
- ✅ **实现参考**：完全基于 `hero_chassis_controller` 的 TF 变换方法
- ✅ **架构清晰**：键盘节点和控制器各自管理自己的坐标系转换

当前可以保持 `speed_mode: "local"`，先专注于测试基线版本的稳定性！
