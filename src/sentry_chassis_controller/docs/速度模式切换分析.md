# 速度模式切换分析：Local vs Global

> 参考实现：`/home/idris/final_ws/reference/hero_chassis_controller`

---

## 一、Hero Controller中的速度模式实现

### 1.1 配置参数

**文件**: `config/default.yaml`
```yaml
speed_mode: "local"  # 可选值："local" 或 "global"
```

### 1.2 核心实现逻辑

**文件**: `src/hero_chassis_controller.cpp::cmdCallback()`

```cpp
void HeroChassisController::cmdCallback(const geometry_msgs::Twist::ConstPtr &msg) {
    geometry_msgs::Twist vel;
    vel.linear.x = msg->linear.x;
    vel.linear.y = msg->linear.y;
    vel.angular.z = msg->angular.z;
    
    // 【关键】速度模式判断
    if (speed_mode_ == "global") {
        try {
            tf::TransformListener tf_listener;
            geometry_msgs::Vector3Stamped vel_local, vel_global;
            
            // 1. 输入速度在odom坐标系（全局）
            vel_global.header.frame_id = "odom";
            vel_global.vector.x = vel.linear.x;
            vel_global.vector.y = vel.linear.y;
            vel_global.vector.z = 0.0;
            
            // 2. 等待TF变换可用
            tf_listener.waitForTransform("base_link", "odom", ros::Time(), ros::Duration(2.0));
            
            // 3. 从odom坐标系转换到base_link坐标系
            tf_listener.transformVector("base_link", vel_global, vel_local);
            
            // 4. 使用转换后的局部速度
            vel.linear.x = vel_local.vector.x;
            vel.linear.y = vel_local.vector.y;
        }
        catch(tf::TransformException& ex) {
            ROS_WARN("TF transform error: %s", ex.what());
            return;
        }
    }
    // 如果是"local"模式，直接使用输入速度（已经在base_link坐标系）
    
    // 后续使用vel.linear.x, vel.linear.y, vel.angular.z计算轮速
    front_left_vel_ = vel.linear.x - vel.linear.y - vel.angular.z*((wheel_track_+wheel_base_)/2.0);
    front_right_vel_ = vel.linear.x + vel.linear.y + vel.angular.z*((wheel_track_+wheel_base_)/2.0);
    back_right_vel_ = vel.linear.x - vel.linear.y + vel.angular.z*((wheel_track_+wheel_base_)/2.0);
    back_left_vel_ = vel.linear.x + vel.linear.y - vel.angular.z*((wheel_track_+wheel_base_)/2.0);
}
```

---

## 二、两种速度模式的区别

### 2.1 Local模式（局部坐标系）

**特点**：
- cmd_vel中的速度**相对于底盘当前朝向**
- vx = 前进/后退（沿底盘前方）
- vy = 左移/右移（沿底盘左侧）
- wz = 旋转（绕底盘中心）

**应用场景**：
- ✅ **键盘手动控制**：W前进、A左移、D右移，符合人的直觉
- ✅ **手柄控制**：摇杆方向对应底盘方向
- ❌ 自主导航：目标点相对位置会随底盘旋转变化

**示例**：
```bash
# 底盘朝向北（yaw=0°），发送 vx=1.0
→ 机器人向北移动

# 底盘旋转90°朝向东（yaw=90°），发送相同的 vx=1.0
→ 机器人向东移动（跟随底盘朝向）
```

---

### 2.2 Global模式（全局坐标系）

**特点**：
- cmd_vel中的速度**相对于odom固定坐标系**
- vx = 向东/向西（odom的x轴）
- vy = 向北/向南（odom的y轴）
- wz = 旋转（绕底盘中心）

**实现原理**：
```cpp
// 输入：全局速度 (odom坐标系)
vel_global = {vx_odom, vy_odom, 0}

// 通过TF变换到局部坐标系
vel_local = T_base_odom * vel_global

// 使用局部速度计算轮速
front_left_vel = vel_local.x - vel_local.y - wz*...
```

**应用场景**：
- ✅ **自主导航**：move_base发送的速度命令
- ✅ **固定方向移动**：无论底盘如何旋转，都向固定方向移动
- ❌ 键盘手动控制：不符合直觉（底盘转向后按键方向不变）

**示例**：
```bash
# 底盘朝向北（yaw=0°），发送 vx_global=1.0（向东）
→ 机器人向东移动

# 底盘旋转90°朝向东（yaw=90°），发送相同的 vx_global=1.0（向东）
→ 机器人仍然向东移动（不受底盘朝向影响）
```

---

## 三、TF坐标变换数学原理

### 3.1 坐标系定义

```
odom坐标系（固定全局）:
    y (北)
    ↑
    |
    └──→ x (东)

base_link坐标系（跟随底盘）:
    x (前)
    ↑
    |
    └──→ y (左)
```

### 3.2 旋转矩阵变换

假设底盘yaw角为θ（逆时针为正）：

```
[ vx_base ]   [ cos(θ)  sin(θ) ] [ vx_odom ]
[ vy_base ] = [-sin(θ)  cos(θ) ] [ vy_odom ]
```

**代码实现**（TF自动处理）：
```cpp
tf_listener.transformVector("base_link", vel_global, vel_local);
```

**手动计算示例**：
```cpp
// 底盘朝向45°，全局速度 vx_odom=1.0, vy_odom=0
double theta = 0.785; // 45° = π/4
double vx_base = cos(theta) * 1.0 + sin(theta) * 0.0;  // = 0.707
double vy_base = -sin(theta) * 1.0 + cos(theta) * 0.0; // = -0.707

// 结果：底盘局部坐标系中，速度变为 (0.707, -0.707)
// 即：前进0.707 m/s，同时右移0.707 m/s
```

---

## 四、您当前的实现分析

### 4.1 当前状态

**文件**: `src/sentry_chassis_controller/src/wheel_pid_controller.cpp`

```cpp
void WheelPidController::cmdVelCallback(const geometry_msgs::Twist::ConstPtr &msg)
{
    double vx = msg->linear.x;
    double vy = msg->linear.y;
    double wz = msg->angular.z;
    
    // 直接使用输入速度进行IK计算
    // 【问题】没有速度模式切换功能！
    double pivots[4], wheels[4];
    sentry_kinematics::inverseKinematics(vx, vy, wz, wheel_base_, wheel_track_, 
                                         pivots, wheels);
    // ...
}
```

**现状**：
- ❌ **只支持Local模式**：输入速度默认相对于base_link
- ❌ **无Global模式**：无法处理全局坐标系速度
- ✅ **适合键盘控制**：符合手动控制的直觉

---

### 4.2 潜在问题场景

#### 场景1：键盘控制（当前正常）
```bash
# 用户按W键，teleop发送 vx=1.0（相对底盘）
→ 机器人前进 ✅ 符合预期
```

#### 场景2：自主导航（可能有问题）
```bash
# move_base发送 vx=1.0, vy=0（假设期望向东移动）
# 但底盘朝向北（yaw=0°）
→ 机器人向北移动 ❌ 不符合导航预期
```

**问题根源**：
- move_base可能期望Global模式（ROS标准）
- 但您的控制器当前只支持Local模式

---

## 五、对比总结

### 5.1 Hero Controller vs 您的实现

| 功能 | Hero Controller | 您的实现 | 建议 |
|------|----------------|---------|------|
| **速度模式切换** | ✅ 支持local/global | ❌ 只支持local | ⭐⭐⭐ 建议添加 |
| **TF坐标变换** | ✅ 使用tf_listener | ❌ 无 | ⭐⭐⭐ 配合模式切换 |
| **配置参数** | ✅ speed_mode参数 | ❌ 无 | ⭐⭐ 易于切换 |
| **应用场景** | 键盘+导航通用 | 仅键盘友好 | - |

---

### 5.2 ROS标准约定

**根据ROS导航栈文档**：
- `cmd_vel`话题的速度**通常**在`base_link`坐标系（Local模式）
- 但某些高级导航可能需要Global模式
- **建议**：提供可配置选项，默认Local模式

---

## 六、添加速度模式切换的实现方案

### 6.1 修改控制器

**文件**: `wheel_pid_controller.cpp`

```cpp
// 1. 添加成员变量
class WheelPidController {
private:
    std::string speed_mode_;  // "local" 或 "global"
    tf::TransformListener* tf_listener_;
};

// 2. 在init()中读取参数
bool WheelPidController::init(...) {
    controller_nh.param<std::string>("speed_mode", speed_mode_, "local");
    
    if (speed_mode_ == "global") {
        tf_listener_ = new tf::TransformListener();
    }
    // ...
}

// 3. 修改cmdVelCallback
void WheelPidController::cmdVelCallback(const geometry_msgs::Twist::ConstPtr &msg)
{
    double vx = msg->linear.x;
    double vy = msg->linear.y;
    double wz = msg->angular.z;
    
    // 【新增】Global模式处理
    if (speed_mode_ == "global") {
        try {
            geometry_msgs::Vector3Stamped vel_global, vel_local;
            vel_global.header.frame_id = "odom";
            vel_global.header.stamp = ros::Time::now();
            vel_global.vector.x = vx;
            vel_global.vector.y = vy;
            vel_global.vector.z = 0.0;
            
            tf_listener_->waitForTransform("base_link", "odom", 
                                           ros::Time(0), ros::Duration(0.1));
            tf_listener_->transformVector("base_link", vel_global, vel_local);
            
            vx = vel_local.vector.x;
            vy = vel_local.vector.y;
        }
        catch (tf::TransformException& ex) {
            ROS_WARN_THROTTLE(1.0, "TF transform error: %s", ex.what());
            return;  // 忽略此次命令
        }
    }
    
    // 后续IK计算保持不变（使用局部速度）
    double pivots[4], wheels[4];
    sentry_kinematics::inverseKinematics(vx, vy, wz, wheel_base_, wheel_track_, 
                                         pivots, wheels);
    // ...
}
```

---

### 6.2 修改配置文件

**文件**: `config/wheel_pid_params.yaml`

```yaml
wheel_pid_controller:
  # 新增速度模式参数
  speed_mode: "local"  # 可选："local"（默认）或 "global"
  
  # 原有参数
  wheel_track: 0.36
  wheel_base: 0.36
  wheel_radius: 0.05
  # ...
```

---

### 6.3 键盘控制节点保持不变

**文件**: `src/sentry_control_key_feature.cpp`

```cpp
// 键盘节点继续发布local速度（相对底盘）
// 不需要修改！
twist_msg.linear.x = vx;  // 前进/后退
twist_msg.linear.y = vy;  // 左移/右移
twist_msg.angular.z = wz; // 旋转
cmd_vel_pub_.publish(twist_msg);
```

**说明**：
- 键盘节点始终发布Local速度
- 如果`speed_mode="local"`：控制器直接使用 ✅
- 如果`speed_mode="global"`：不建议用于键盘控制 ❌

---

## 七、使用建议

### 7.1 推荐配置

**键盘手动控制场景**：
```yaml
speed_mode: "local"  # ← 推荐
```
- ✅ W键前进符合直觉
- ✅ 无需TF查询，性能更好
- ✅ 当前实现已满足需求

**自主导航场景**（如果将来使用move_base）：
```yaml
speed_mode: "global"  # ← 可选
```
- ✅ 符合ROS导航栈可能的期望
- ⚠️ 需要TF变换，有轻微延迟
- ⚠️ 确保odom→base_link的TF正确发布

---

### 7.2 当前是否需要添加？

#### 优先级评估

| 因素 | 评分 | 说明 |
|------|------|------|
| **当前需求** | ⭐⭐ 低 | 仅键盘控制，Local模式已满足 |
| **未来扩展性** | ⭐⭐⭐⭐ 高 | 如果将来做导航，需要此功能 |
| **实现难度** | ⭐⭐ 低 | 代码修改量约30行 |
| **性能影响** | ⭐⭐⭐ 中 | Global模式需要TF查询（~1ms） |

#### 建议

**现阶段（调试基线版本）**：
- ❌ **不建议立即添加**
- 理由：增加复杂度，可能引入新问题
- 优先保证基线版本稳定

**后续优化阶段**：
- ✅ **建议作为可选功能添加**
- 理由：提高系统通用性，为导航做准备
- 默认保持`local`模式，向后兼容

---

## 八、完整代码示例

### 8.1 头文件修改

**文件**: `include/sentry_chassis_controller/wheel_pid_controller.hpp`

```cpp
#include <tf/transform_listener.h>  // 新增

class WheelPidController : public controller_interface::Controller<hardware_interface::EffortJointInterface>
{
private:
    // 新增成员
    std::string speed_mode_;           // "local" 或 "global"
    tf::TransformListener* tf_listener_;  // TF监听器（仅Global模式使用）
    
    // 原有成员...
};
```

---

### 8.2 源文件修改（关键部分）

**文件**: `src/wheel_pid_controller.cpp`

```cpp
// init()中初始化
bool WheelPidController::init(...)
{
    // ... 原有代码 ...
    
    // 读取速度模式参数
    controller_nh.param<std::string>("speed_mode", speed_mode_, "local");
    ROS_INFO("WheelPidController: speed_mode = %s", speed_mode_.c_str());
    
    // 如果是Global模式，创建TF监听器
    if (speed_mode_ == "global") {
        tf_listener_ = new tf::TransformListener();
        ROS_INFO("WheelPidController: TF listener created for global mode");
    } else {
        tf_listener_ = nullptr;
    }
    
    // ... 原有代码 ...
    return true;
}

// cmdVelCallback()中处理坐标变换
void WheelPidController::cmdVelCallback(const geometry_msgs::Twist::ConstPtr &msg)
{
    double vx = msg->linear.x;
    double vy = msg->linear.y;
    double wz = msg->angular.z;
    
    // Global模式：odom → base_link坐标变换
    if (speed_mode_ == "global" && tf_listener_) {
        try {
            geometry_msgs::Vector3Stamped vel_global, vel_local;
            vel_global.header.frame_id = "odom";
            vel_global.header.stamp = ros::Time(0);  // 使用最新可用的TF
            vel_global.vector.x = vx;
            vel_global.vector.y = vy;
            vel_global.vector.z = 0.0;
            
            // 等待TF（最多100ms）
            if (tf_listener_->waitForTransform("base_link", "odom", 
                                                ros::Time(0), ros::Duration(0.1))) {
                tf_listener_->transformVector("base_link", vel_global, vel_local);
                vx = vel_local.vector.x;
                vy = vel_local.vector.y;
                
                ROS_DEBUG_THROTTLE(1.0, "Global→Local: (%.2f,%.2f)→(%.2f,%.2f)",
                                   vel_global.vector.x, vel_global.vector.y, vx, vy);
            } else {
                ROS_WARN_THROTTLE(1.0, "TF timeout: odom→base_link");
                return;  // 忽略此次命令
            }
        }
        catch (tf::TransformException& ex) {
            ROS_WARN_THROTTLE(1.0, "TF error: %s", ex.what());
            return;
        }
    }
    
    // 后续IK计算（使用局部速度vx, vy, wz）
    // ... 原有代码保持不变 ...
}
```

---

### 8.3 CMakeLists.txt修改

```cmake
find_package(catkin REQUIRED COMPONENTS
  # ... 原有依赖 ...
  tf  # 新增
)

catkin_package(
  CATKIN_DEPENDS
    # ... 原有依赖 ...
    tf  # 新增
)
```

---

### 8.4 package.xml修改

```xml
<depend>tf</depend>  <!-- 新增 -->
```

---

## 九、总结

### 9.1 Hero Controller的实现亮点

✅ **灵活的速度模式切换**：
- 通过`speed_mode`参数轻松切换Local/Global
- TF坐标变换自动处理旋转矩阵

✅ **健壮的异常处理**：
- TF超时保护（`waitForTransform`）
- try-catch捕获异常，避免崩溃

✅ **向后兼容**：
- 默认Local模式，不影响现有键盘控制

---

### 9.2 您的下一步建议

#### 短期（当前阶段）：
1. **保持现状** ✅
   - Local模式已满足键盘控制需求
   - 专注于基线版本稳定性调试

2. **文档记录** ✅
   - 已创建本分析文档
   - 为将来添加功能做准备

#### 中期（基线稳定后）：
3. **可选添加Global模式** ⭐⭐⭐
   - 参考上述代码示例
   - 默认保持`local`，配置可切换

4. **测试验证**
   - Local模式：键盘控制测试
   - Global模式：rostopic手动发布测试

#### 长期（导航集成时）：
5. **导航栈集成**
   - 确认move_base期望的速度坐标系
   - 根据需要切换模式

---

**文档版本**: v1.0  
**创建时间**: 2025-11-29  
**参考实现**: hero_chassis_controller  
**状态**: ✅ 分析完成，建议后续可选添加
