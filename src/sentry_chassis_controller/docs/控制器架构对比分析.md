# èˆµè½®åº•ç›˜æ§åˆ¶å™¨æ¶æ„å¯¹æ¯”åˆ†æ

> å¯¹æ¯”å¯¹è±¡ï¼š
> - **your_impl**: `/home/idris/final_ws/src/sentry_chassis_controller`
> - **ros_official**: `/home/idris/final_ws/src/ros_controllers/four_wheel_steering_controller`
> - **hero_impl**: `/home/idris/final_ws/reference/hero_chassis_controller`

---

## ä¸€ã€æ•´ä½“æ¶æ„å¯¹æ¯”

### 1.1 æ§åˆ¶å™¨ç±»å‹

| ç»´åº¦ | Your Implementation | ROS Official | Hero Controller |
|------|-------------------|--------------|-----------------|
| **ç¡¬ä»¶æ¥å£** | `EffortJointInterface` | `VelocityJointInterface` | `EffortJointInterface` |
| **æ§åˆ¶æ–¹å¼** | PIDæ§åˆ¶åŠ›çŸ© | ç›´æ¥é€Ÿåº¦æ§åˆ¶ | PIDæ§åˆ¶åŠ›çŸ© |
| **èˆµè½®ç±»å‹** | 4ä¸ªç‹¬ç«‹èˆµè½® | å‰åå¯¹ç§°è½¬å‘ | âŒ æ— èˆµè½®ï¼ˆéº¦å…‹çº³å§†ï¼‰ |
| **é‡Œç¨‹è®¡** | ç‹¬ç«‹èŠ‚ç‚¹FK | å†…ç½®Odometryç±» | å†…ç½®ç®€å•ç§¯åˆ† |

**å…³é”®å·®å¼‚**ï¼š
- âœ… **æ‚¨çš„å®ç°**ä½¿ç”¨EffortJointInterfaceï¼Œéœ€è¦PIDæ§åˆ¶æ¯ä¸ªå…³èŠ‚çš„åŠ›çŸ©
- âœ… **å®˜æ–¹å®ç°**ä½¿ç”¨VelocityJointInterfaceï¼Œç›´æ¥è®¾ç½®è½®é€Ÿï¼ˆæ›´ç®€å•ï¼‰
- âŒ **Hero Controller**æ˜¯éº¦å…‹çº³å§†è½®ï¼Œ**ä¸é€‚ç”¨**èˆµè½®ç³»ç»Ÿ

---

## äºŒã€æ–‡ä»¶ç»“æ„å¯¹æ¯”

### 2.1 Your Implementation (å½“å‰)

```
sentry_chassis_controller/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ wheel_pid_controller.cpp       # ä¸»æ§åˆ¶å™¨ï¼šIK + PIDæ§åˆ¶
â”‚   â””â”€â”€ forward_kinematics.cpp         # ç‹¬ç«‹FKèŠ‚ç‚¹ï¼šè®¢é˜…joint_states â†’ å‘å¸ƒodom
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ wheel_pid_controller.hpp
â”‚   â””â”€â”€ inverse_kinematics.hpp         # IKå·¥å…·å‡½æ•°
â”œâ”€â”€ launch/
â”‚   â”œâ”€â”€ sentry_with_odom_feature.launch  # æ€»å¯åŠ¨ï¼šåŒ…å«PID+teleop+yaw
â”‚   â””â”€â”€ sentry_pid_test_fixed.launch     # åŠ è½½æ§åˆ¶å™¨å’Œå‚æ•°
â””â”€â”€ config/
    â”œâ”€â”€ wheel_pid_params.yaml          # PIDå‚æ•°
    â””â”€â”€ teleop_feature.yaml            # é”®ç›˜æ§åˆ¶å‚æ•°
```

**ç‰¹ç‚¹**ï¼š
- âœ… **åˆ†ç¦»è®¾è®¡**ï¼šæ§åˆ¶å™¨ï¼ˆIK+PIDï¼‰å’Œé‡Œç¨‹è®¡ï¼ˆFKï¼‰æ˜¯ç‹¬ç«‹èŠ‚ç‚¹
- âœ… **çµæ´»æ€§é«˜**ï¼šå¯ä»¥å•ç‹¬è°ƒè¯•FKèŠ‚ç‚¹
- âš ï¸ **é€šä¿¡å»¶è¿Ÿ**ï¼šé€šè¿‡`/joint_states`è¯é¢˜é€šä¿¡ï¼ˆ~1-2mså»¶è¿Ÿï¼‰

---

### 2.2 ROS Official Implementation

```
four_wheel_steering_controller/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ four_wheel_steering_controller.cpp  # ä¸»æ§åˆ¶å™¨ï¼šIK + é‡Œç¨‹è®¡ä¸€ä½“
â”‚   â”œâ”€â”€ odometry.cpp                         # Odometryç±»ï¼šFKå®ç°
â”‚   â””â”€â”€ speed_limiter.cpp                    # é€Ÿåº¦é™å¹…å·¥å…·
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ four_wheel_steering_controller.h
â”‚   â”œâ”€â”€ odometry.h
â”‚   â””â”€â”€ speed_limiter.h
â””â”€â”€ test/
    â””â”€â”€ four_wheel_steering_controller_test.cpp
```

**ç‰¹ç‚¹**ï¼š
- âœ… **ä¸€ä½“åŒ–è®¾è®¡**ï¼šæ§åˆ¶å™¨å’Œé‡Œç¨‹è®¡åœ¨åŒä¸€ä¸ªç±»ä¸­
- âœ… **å®æ—¶æ€§å¼º**ï¼šæ— è¯é¢˜é€šä¿¡å»¶è¿Ÿï¼Œç›´æ¥åœ¨`update()`ä¸­è°ƒç”¨FK
- âš ï¸ **è€¦åˆåº¦é«˜**ï¼šä¿®æ”¹FKéœ€è¦é‡æ–°ç¼–è¯‘æ•´ä¸ªæ§åˆ¶å™¨

---

## ä¸‰ã€æ ¸å¿ƒé€»è¾‘å¯¹æ¯”

### 3.1 æ§åˆ¶å™¨æ›´æ–°å¾ªç¯

#### Your Implementation (`wheel_pid_controller.cpp::update()`)

```cpp
void WheelPidController::update(const ros::Time &time, const ros::Duration &period)
{
    // 1. è¯»å–å…³èŠ‚çŠ¶æ€ï¼ˆç”¨äºå‘å¸ƒjoint_statesï¼‰
    double lf_wheel_pos = front_left_wheel_joint_.getPosition();
    double lf_wheel_vel = front_left_wheel_joint_.getVelocity();
    // ... è¯»å–æ‰€æœ‰8ä¸ªå…³èŠ‚ ...
    
    // 2. å‘å¸ƒjoint_statesè¯é¢˜ï¼ˆä¾›ç‹¬ç«‹FKèŠ‚ç‚¹ä½¿ç”¨ï¼‰
    sensor_msgs::JointState js;
    js.header.stamp = time;
    js.name = {"left_front_wheel_joint", "right_front_wheel_joint", ...};
    js.position = {lf_wheel_pos, rf_wheel_pos, ...};
    js.velocity = {lf_wheel_vel, rf_wheel_vel, ...};
    joint_states_pub_.publish(js);  // âš ï¸ å‘å¸ƒåˆ°è¯é¢˜
    
    // 3. PIDæ§åˆ¶ï¼ˆæ ¹æ®pivot_cmd_å’Œwheel_cmd_è®¡ç®—åŠ›çŸ©ï¼‰
    double p0 = pid_lf_.computeCommand(pivot_cmd_[0] - pivot_pos[0], period);
    // ... 8ä¸ªPIDæ§åˆ¶å™¨ ...
    front_left_pivot_joint_.setCommand(p0);  // è®¾ç½®åŠ›çŸ©
    
    // 4. åº”ç”¨åŠŸç‡é™åˆ¶ï¼ˆå¯é€‰ï¼‰
    if (power_limit_enabled_) { /* é™åˆ¶æ€»åŠŸç‡ */ }
}
```

**æµç¨‹**ï¼š
1. è¯»å–ä¼ æ„Ÿå™¨ â†’ 2. å‘å¸ƒjoint_states â†’ 3. PIDæ§åˆ¶ â†’ 4. è®¾ç½®åŠ›çŸ©
- âš ï¸ **é‡Œç¨‹è®¡åœ¨å¤–éƒ¨**ï¼š`forward_kinematics`èŠ‚ç‚¹è®¢é˜…`/joint_states`è®¡ç®—odom

---

#### ROS Official (`four_wheel_steering_controller.cpp::update()`)

```cpp
void FourWheelSteeringController::update(const ros::Time& time, const ros::Duration& period)
{
    // 1. æ›´æ–°é‡Œç¨‹è®¡ï¼ˆå†…éƒ¨è°ƒç”¨ï¼‰
    updateOdometry(time);
    
    // 2. æ›´æ–°æ§åˆ¶æŒ‡ä»¤
    updateCommand(time, period);
}

void FourWheelSteeringController::updateOdometry(const ros::Time& time)
{
    // 1. è¯»å–å…³èŠ‚çŠ¶æ€
    double fl_speed = front_wheel_joints_[0].getVelocity();
    double fl_steering = front_steering_joints_[0].getPosition();
    // ... è¯»å–æ‰€æœ‰8ä¸ªå…³èŠ‚ ...
    
    // 2. è®¡ç®—ç­‰æ•ˆå‰åè½®è½¬å‘è§’ï¼ˆå…³é”®ï¼ï¼‰
    double front_steering_pos = atan(2*tan(fl_steering)*tan(fr_steering)/
                                      (tan(fl_steering) + tan(fr_steering)));
    double rear_steering_pos = atan(2*tan(rl_steering)*tan(rr_steering)/
                                     (tan(rl_steering) + tan(rr_steering)));
    
    // 3. è°ƒç”¨Odometryç±»çš„FKè®¡ç®—
    odometry_.update(fl_speed, fr_speed, rl_speed, rr_speed,
                     front_steering_pos, rear_steering_pos, time);  // âœ… ç›´æ¥è°ƒç”¨
    
    // 4. å‘å¸ƒodomæ¶ˆæ¯å’ŒTF
    odom_pub_->msg_.pose.pose.position.x = odometry_.getX();
    odom_pub_->msg_.twist.twist.linear.x = odometry_.getLinearX();
    odom_pub_->unlockAndPublish();
    tf_odom_pub_->unlockAndPublish();
}
```

**æµç¨‹**ï¼š
1. è¯»å–ä¼ æ„Ÿå™¨ â†’ 2. è®¡ç®—ç­‰æ•ˆè½¬å‘è§’ â†’ 3. FKè®¡ç®— â†’ 4. å‘å¸ƒodom
- âœ… **é‡Œç¨‹è®¡å†…ç½®**ï¼šæ— è¯é¢˜é€šä¿¡ï¼Œç›´æ¥è°ƒç”¨`odometry_.update()`

---

### 3.2 å…³é”®å·®å¼‚ï¼šç­‰æ•ˆè½¬å‘è§’è®¡ç®—

#### âš ï¸ **é‡å¤§å‘ç°**ï¼šå®˜æ–¹å®ç°æœ‰é¢„å¤„ç†æ­¥éª¤ï¼

**ROS Official** (åœ¨FKå‰è®¡ç®—)ï¼š
```cpp
// è®¡ç®—ç­‰æ•ˆå‰è½®è½¬å‘è§’ï¼ˆè™šæ‹Ÿä¸­å¿ƒå‰è½®ï¼‰
double front_steering_pos = atan(2*tan(fl_steering)*tan(fr_steering)/
                                  (tan(fl_steering) + tan(fr_steering)));

// è®¡ç®—ç­‰æ•ˆåè½®è½¬å‘è§’ï¼ˆè™šæ‹Ÿä¸­å¿ƒåè½®ï¼‰
double rear_steering_pos = atan(2*tan(rl_steering)*tan(rr_steering)/
                                 (tan(rl_steering) + tan(rr_steering)));

// ç„¶åä¼ å…¥FK
odometry_.update(fl_speed, fr_speed, rl_speed, rr_speed,
                 front_steering_pos, rear_steering_pos, time);
```

**æ•°å­¦æ„ä¹‰**ï¼š
- å°†4ä¸ªç‹¬ç«‹èˆµè§’ â†’ ç®€åŒ–ä¸º2ä¸ªè™šæ‹Ÿè½¬å‘è§’ï¼ˆå‰/åï¼‰
- æ¶ˆé™¤å·¦å³è½®é˜¿å…‹æ›¼è½¬å‘çš„ä¸å¯¹ç§°æ€§
- ç®€åŒ–FKè®¡ç®—ï¼Œæé«˜æ•°å€¼ç¨³å®šæ€§

---

**Your Implementation** (ç›´æ¥ç”¨4ä¸ªè½®è§’)ï¼š
```cpp
// forward_kinematics.cppä¸­
for (int i = 0; i < 4; ++i)
{
    double pivot_pos = 0.0;  // ç›´æ¥è¯»å–4ä¸ªpivotè§’åº¦
    if (idx.find(pivot_joint_names_[i]) != idx.end())
    {
        size_t j = idx[pivot_joint_names_[i]];
        pivot_pos = msg->position[j];  // âœ… ç›´æ¥ä½¿ç”¨
    }
    
    // æ„å»ºAçŸ©é˜µ
    A(i, 0) = cos(pivot_pos);
    A(i, 1) = sin(pivot_pos);
    A(i, 2) = -ry * cos(pivot_pos) + rx * sin(pivot_pos);  // å·²ä¿®æ­£
    b(i) = wheel_vel * wheel_radius_;
}

// æœ€å°äºŒä¹˜æ±‚è§£
Eigen::Vector3d sol = (A.transpose() * A).ldlt().solve(A.transpose() * b);
```

**å¯¹æ¯”**ï¼š
- âœ… æ‚¨çš„æ–¹æ³•ï¼š4Ã—3æœ€å°äºŒä¹˜ï¼Œæ•°å­¦ä¸Šå®Œå…¨æ­£ç¡®
- âš ï¸ å®˜æ–¹æ–¹æ³•ï¼šå…ˆç®€åŒ–ä¸º2ä¸ªç­‰æ•ˆè§’ï¼Œå†ç”¨ç®€åŒ–FKå…¬å¼
- ğŸ“Š **ç²¾åº¦å·®å¼‚**ï¼šç†è®ºä¸Šæ‚¨çš„æ–¹æ³•æ›´ç²¾ç¡®ï¼ˆè€ƒè™‘äº†æ‰€æœ‰4ä¸ªè½®å­ï¼‰
- ğŸ“Š **æ•°å€¼ç¨³å®šæ€§**ï¼šå®˜æ–¹æ–¹æ³•åœ¨è½®è§’ä¸å¯¹ç§°æ—¶æ›´ç¨³å®š

---

### 3.3 é‡Œç¨‹è®¡ç§¯åˆ†æ–¹æ³•

#### Your Implementation (`forward_kinematics.cpp`)

```cpp
// è®¡ç®—ä¸–ç•Œåæ ‡ç³»ä¸‹çš„é€Ÿåº¦å¢é‡
double cos_yaw = std::cos(yaw_);
double sin_yaw = std::sin(yaw_);
double dx = (vx * cos_yaw - vy * sin_yaw) * dt;
double dy = (vx * sin_yaw + vy * cos_yaw) * dt;
double dyaw = wz * dt;

// ç§¯åˆ†
x_ += dx;
y_ += dy;
yaw_ += dyaw;

ROS_INFO_THROTTLE(5.0, "World pose update: dx=%.3f, dy=%.3f, dyaw=%.3f rad", dx, dy, dyaw);
ROS_INFO_THROTTLE(5.0, "New world pose: x=%.3f, y=%.3f, yaw=%.3f", x_, y_, yaw_);
```

**ç‰¹ç‚¹**ï¼š
- âœ… æ ‡å‡†çš„æ¬§æ‹‰ç§¯åˆ†æ³•
- âœ… è€ƒè™‘äº†yawè§’çš„æ—‹è½¬å˜æ¢
- âœ… æœ‰è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—

---

#### ROS Official (`odometry.cpp`)

```cpp
// odometry.cpp::update()ä¸­çš„ç§¯åˆ†ï¼ˆç±»ä¼¼ï¼‰
void Odometry::update(double fl_speed, double fr_speed, double rl_speed, double rr_speed,
                      double front_steering, double rear_steering, const ros::Time& time)
{
    // 1. è®¡ç®—è½¦ä½“åæ ‡ç³»é€Ÿåº¦
    computeVelocity(fl_speed, fr_speed, rl_speed, rr_speed, 
                    front_steering, rear_steering);
    
    // 2. ä¸–ç•Œåæ ‡ç³»ç§¯åˆ†
    double dt = (time - timestamp_).toSec();
    double cos_heading = cos(heading_);
    double sin_heading = sin(heading_);
    x_ += (linear_x_ * cos_heading - linear_y_ * sin_heading) * dt;
    y_ += (linear_x_ * sin_heading + linear_y_ * cos_heading) * dt;
    heading_ += angular_ * dt;
    
    // 3. é€Ÿåº¦æ»¤æ³¢ï¼ˆæ»‘åŠ¨çª—å£ï¼‰
    linear_acc_x_->accumulate(linear_x_);
    linear_acc_y_->accumulate(linear_y_);
    angular_acc_->accumulate(angular_);
}
```

**ç‰¹ç‚¹**ï¼š
- âœ… ä¸æ‚¨çš„æ–¹æ³•ç›¸åŒçš„ç§¯åˆ†å…¬å¼
- âœ… é¢å¤–çš„é€Ÿåº¦æ»¤æ³¢ï¼ˆæ»‘åŠ¨çª—å£å¹³å‡ï¼‰
- âœ… é¢å¤–çš„åŠ é€Ÿåº¦è®¡ç®—

---

## å››ã€å…³é”®é—®é¢˜è¯Šæ–­

### 4.1 å½“å‰æ¶æ„çš„æ½œåœ¨é—®é¢˜

| é—®é¢˜ | å½±å“ | ä¸¥é‡æ€§ | æ¥æº |
|------|------|--------|------|
| **è¯é¢˜é€šä¿¡å»¶è¿Ÿ** | FKèŠ‚ç‚¹é€šè¿‡`/joint_states`è®¢é˜…ï¼Œæœ‰1-2mså»¶è¿Ÿ | âš ï¸ ä¸­ | æ¶æ„è®¾è®¡ |
| **æ— ç­‰æ•ˆè½¬å‘è§’** | ç›´æ¥ç”¨4ä¸ªè½®è§’ï¼Œåœ¨ä¸å¯¹ç§°æ—¶å¯èƒ½æ•°å€¼ä¸ç¨³å®š | âš ï¸ ä¸­ | FKå®ç° |
| **æ— é€Ÿåº¦æ»¤æ³¢** | ä½ç½®å¾®åˆ†å¾—åˆ°çš„é€Ÿåº¦å™ªå£°å¤§ | âš ï¸ ä¸­ | FKå®ç° |
| **æ— è¶…æ—¶ä¿æŠ¤** | cmd_velé•¿æ—¶é—´æ— æ›´æ–°æ—¶ä¸ä¼šè‡ªåŠ¨åˆ¹è½¦ | âš ï¸ ä¸­ | æ§åˆ¶å™¨ |
| **PIDè¾“å‡ºæ— é™å¹…** | å¤§è¯¯å·®æ—¶å¯èƒ½äº§ç”Ÿå·¨å¤§åŠ›çŸ© | âŒ é«˜ | å·²çŸ¥é—®é¢˜ |

---

### 4.2 å¯¹æ¯”å®˜æ–¹å®ç°çš„ç¼ºå¤±åŠŸèƒ½

#### âœ… å®˜æ–¹æœ‰ï¼Œæ‚¨æ²¡æœ‰ï¼š

1. **é€Ÿåº¦é™åˆ¶å™¨** (`speed_limiter.cpp`)
   ```cpp
   class SpeedLimiter {
       void limit(double& v, double v0, double v1, double dt);  // é™åˆ¶åŠ é€Ÿåº¦
       void limit_jerk(double& v, double v0, double v1, double v2, double dt);  // é™åˆ¶Jerk
   };
   ```
   - ä½œç”¨ï¼šå¹³æ»‘é€Ÿåº¦å˜åŒ–ï¼Œé˜²æ­¢æ€¥åŠ é€Ÿ/æ€¥è½¬å‘
   - å»ºè®®ï¼š**å¼ºçƒˆæ¨èæ·»åŠ **

2. **å‘½ä»¤è¶…æ—¶ä¿æŠ¤**
   ```cpp
   const double dt = (time - cmd->stamp).toSec();
   if (dt > cmd_vel_timeout_)  // é»˜è®¤0.5ç§’
   {
       curr_cmd_twist.lin_x = 0.0;  // è‡ªåŠ¨åˆ¹è½¦
       curr_cmd_twist.ang = 0.0;
   }
   ```
   - ä½œç”¨ï¼šé”®ç›˜æ§åˆ¶æ–­å¼€æ—¶è‡ªåŠ¨åœè½¦
   - å»ºè®®ï¼š**å¿…é¡»æ·»åŠ **

3. **é€Ÿåº¦æ»¤æ³¢** (æ»‘åŠ¨çª—å£å¹³å‡)
   ```cpp
   // odometry.hä¸­
   RollingMeanAccumulator<double> linear_acc_x_;  // 10ä¸ªæ ·æœ¬å¹³å‡
   RollingMeanAccumulator<double> angular_acc_;
   ```
   - ä½œç”¨ï¼šå¹³æ»‘ä½ç½®å¾®åˆ†å¾—åˆ°çš„é€Ÿåº¦ï¼Œå‡å°‘å™ªå£°
   - å»ºè®®ï¼š**æ¨èæ·»åŠ **

4. **ç­‰æ•ˆè½¬å‘è§’è®¡ç®—**
   ```cpp
   // åœ¨FKå‰é¢„å¤„ç†
   double front_eq = atan(2*tan(fl)*tan(fr)/(tan(fl)+tan(fr)));
   double rear_eq = atan(2*tan(rl)*tan(rr)/(tan(rl)+tan(rr)));
   ```
   - ä½œç”¨ï¼šç®€åŒ–FKè®¡ç®—ï¼Œæé«˜æ•°å€¼ç¨³å®šæ€§
   - å»ºè®®ï¼š**å¯é€‰ï¼Œæ‚¨çš„æœ€å°äºŒä¹˜æ–¹æ³•å·²è¶³å¤Ÿ**

---

## äº”ã€hero_chassis_controlleråˆ†æ

### 5.1 ä¸ºä»€ä¹ˆä¸é€‚ç”¨ï¼Ÿ

```cpp
// hero_chassis_controller.cpp
void HeroChassisController::cmdCallback(const geometry_msgs::Twist::ConstPtr &msg)
{
    // ç›´æ¥ç”¨éº¦å…‹çº³å§†è½®å…¬å¼
    front_left_vel_  = (vel.linear.x - vel.linear.y - vel.angular.z * (wheel_base_ + wheel_track_) / 2.0) / wheel_radius_;
    front_right_vel_ = (vel.linear.x + vel.linear.y + vel.angular.z * (wheel_base_ + wheel_track_) / 2.0) / wheel_radius_;
    back_left_vel_   = (vel.linear.x + vel.linear.y - vel.angular.z * (wheel_base_ + wheel_track_) / 2.0) / wheel_radius_;
    back_right_vel_  = (vel.linear.x - vel.linear.y + vel.angular.z * (wheel_base_ + wheel_track_) / 2.0) / wheel_radius_;
}
```

**å…³é”®å·®å¼‚**ï¼š
- âŒ **æ— èˆµè§’æ§åˆ¶**ï¼šåªæœ‰4ä¸ªè½®é€Ÿï¼Œæ²¡æœ‰pivotå…³èŠ‚
- âŒ **éº¦å…‹çº³å§†è½®è¿åŠ¨å­¦**ï¼šä¸èˆµè½®å®Œå…¨ä¸åŒ
- âŒ **ç®€å•é‡Œç¨‹è®¡**ï¼šç›´æ¥é€Ÿåº¦ç§¯åˆ†ï¼Œæ— FK
- **ç»“è®º**ï¼š**å®Œå…¨ä¸é€‚ç”¨**èˆµè½®ç³»ç»Ÿï¼Œä»…ä¾›å‚è€ƒåŠŸç‡é™åˆ¶å®ç°

---

## å…­ã€æ”¹è¿›å»ºè®®

### 6.1 çŸ­æœŸæ”¹è¿›ï¼ˆåŸºçº¿ç‰ˆæœ¬ä¼˜åŒ–ï¼‰

#### 1. æ·»åŠ å‘½ä»¤è¶…æ—¶ä¿æŠ¤ â­â­â­â­â­
```cpp
// wheel_pid_controller.cpp::cmdVelCallback()
void WheelPidController::cmdVelCallback(const geometry_msgs::Twist::ConstPtr &msg)
{
    last_cmd_time_ = ros::Time::now();  // è®°å½•æ—¶é—´
    // ... åŸæœ‰é€»è¾‘ ...
}

// wheel_pid_controller.cpp::update()
void WheelPidController::update(const ros::Time &time, const ros::Duration &period)
{
    // æ£€æŸ¥è¶…æ—¶ï¼ˆ0.5ç§’ï¼‰
    if ((time - last_cmd_time_).toSec() > 0.5)
    {
        for (int i = 0; i < 4; ++i)
        {
            pivot_cmd_[i] = 0.0;  // ä¿æŒå½“å‰èˆµè§’
            wheel_cmd_[i] = 0.0;  // è½®é€Ÿå½’é›¶
        }
        ROS_WARN_THROTTLE(1.0, "cmd_vel timeout! Emergency stop.");
    }
    // ... åŸæœ‰PIDé€»è¾‘ ...
}
```

#### 2. æ·»åŠ é€Ÿåº¦æ»¤æ³¢ï¼ˆç®€å•ç§»åŠ¨å¹³å‡ï¼‰ â­â­â­â­
```cpp
// forward_kinematics.cppä¸­
class MovingAverage {
    std::deque<double> buffer_;
    size_t window_size_;
public:
    MovingAverage(size_t size) : window_size_(size) {}
    double update(double new_val) {
        buffer_.push_back(new_val);
        if (buffer_.size() > window_size_) buffer_.pop_front();
        return std::accumulate(buffer_.begin(), buffer_.end(), 0.0) / buffer_.size();
    }
};

// åœ¨ç±»ä¸­æ·»åŠ 
MovingAverage vx_filter_(10), vy_filter_(10), wz_filter_(10);

// åœ¨FKè®¡ç®—å
vx = vx_filter_.update(vx);
vy = vy_filter_.update(vy);
wz = wz_filter_.update(wz);
```

#### 3. PIDè¾“å‡ºé™å¹… â­â­â­â­â­
```cpp
// wheel_pid_controller.cpp::update()
double p0 = pid_lf_.computeCommand(pivot_cmd_[0] - pivot_pos[0], period);
p0 = std::max(-5.0, std::min(5.0, p0));  // é™åˆ¶Â±5 Nm
```

---

### 6.2 ä¸­æœŸæ”¹è¿›ï¼ˆæ¶æ„ä¼˜åŒ–ï¼‰

#### 1. è€ƒè™‘ç­‰æ•ˆè½¬å‘è§’è®¡ç®— â­â­â­
```cpp
// forward_kinematics.cpp::jointStatesCB()ä¸­
// åœ¨æ„å»ºAçŸ©é˜µå‰æ·»åŠ ï¼š
double front_eq = 0.0, rear_eq = 0.0;
if (fabs(pivot_pos[0]) > 0.001 || fabs(pivot_pos[1]) > 0.001)
{
    front_eq = atan(2.0 * tan(pivot_pos[0]) * tan(pivot_pos[1]) /
                    (tan(pivot_pos[0]) + tan(pivot_pos[1])));
}
if (fabs(pivot_pos[2]) > 0.001 || fabs(pivot_pos[3]) > 0.001)
{
    rear_eq = atan(2.0 * tan(pivot_pos[2]) * tan(pivot_pos[3]) /
                   (tan(pivot_pos[2]) + tan(pivot_pos[3])));
}

// ç„¶åç”¨ç®€åŒ–çš„FKå…¬å¼ï¼ˆå‚è€ƒå®˜æ–¹odometry.cppï¼‰
// æˆ–è€…ä¿æŒæ‚¨çš„æœ€å°äºŒä¹˜æ–¹æ³•ï¼ˆå·²è¶³å¤Ÿç²¾ç¡®ï¼‰
```

#### 2. åˆå¹¶æ§åˆ¶å™¨å’Œé‡Œç¨‹è®¡ï¼ˆå¯é€‰ï¼‰ â­â­
- **ä¼˜ç‚¹**ï¼šæ¶ˆé™¤è¯é¢˜é€šä¿¡å»¶è¿Ÿï¼Œå®æ—¶æ€§æ›´å¼º
- **ç¼ºç‚¹**ï¼šä»£ç è€¦åˆåº¦é«˜ï¼Œè°ƒè¯•ä¸ä¾¿
- **å»ºè®®**ï¼š**æš‚æ—¶ä¿æŒåˆ†ç¦»**ï¼Œæ‚¨çš„æ¶æ„æ›´çµæ´»

---

### 6.3 é•¿æœŸæ”¹è¿›ï¼ˆé«˜çº§åŠŸèƒ½ï¼‰

#### 1. æ·»åŠ é€Ÿåº¦é™åˆ¶å™¨ â­â­â­â­
å‚è€ƒå®˜æ–¹`speed_limiter.cpp`å®ç°

#### 2. æ·»åŠ åŠŸç‡ä¼˜åŒ– â­â­â­
æ‚¨å·²ç»æœ‰`power_limit_enabled_`ï¼Œå¯ä»¥å‚è€ƒheroçš„å®ç°ä¼˜åŒ–

#### 3. æ·»åŠ å¤šç§æ§åˆ¶æ¨¡å¼ â­â­
å‚è€ƒPythonæ–‡æ¡£çš„ä¸‰ç§æ¨¡å¼ï¼ˆopposite/in-phase/pivotï¼‰

---

## ä¸ƒã€æµ‹è¯•å»ºè®®

### 7.1 éªŒè¯åŸºçº¿ç‰ˆæœ¬ç¨³å®šæ€§

1. **é™æ­¢æµ‹è¯•**
   ```bash
   roslaunch sentry_chassis_controller sentry_with_odom_feature.launch
   # ä¸å‘é€cmd_velï¼Œè§‚å¯Ÿé‡Œç¨‹è®¡æ˜¯å¦æ¼‚ç§»
   rostopic echo /odom | grep -E "position|orientation"
   ```

2. **å‰è¿›æµ‹è¯•**
   ```bash
   # æŒç»­æŒ‰Wé”®å‰è¿›10ç§’
   rostopic echo /odom | tee odom_forward.log
   # æ£€æŸ¥yawæ˜¯å¦ç¨³å®šï¼ˆ<5Â°ï¼‰
   ```

3. **æ—‹è½¬æµ‹è¯•**
   ```bash
   # æŒç»­æŒ‰Aé”®å·¦è½¬10ç§’
   # æ£€æŸ¥x/yæ˜¯å¦æ¼‚ç§»ï¼Œyawæ˜¯å¦çº¿æ€§å¢é•¿
   ```

4. **æ¨ªç§»æµ‹è¯•**ï¼ˆå¦‚æœIKæ”¯æŒï¼‰
   ```bash
   # ç»™vx=0, vy=0.5
   # è§‚å¯Ÿèˆµè§’æ˜¯å¦æ­£å¸¸ï¼ˆåº”è¯¥~90Â°ï¼‰
   ```

---

### 7.2 æ·»åŠ æ”¹è¿›åæµ‹è¯•

1. **è¶…æ—¶ä¿æŠ¤æµ‹è¯•**
   ```bash
   # å‘é€cmd_velåç«‹å³Ctrl+Cé”®ç›˜èŠ‚ç‚¹
   # è§‚å¯Ÿæœºå™¨äººæ˜¯å¦0.5ç§’å†…åœæ­¢
   ```

2. **æ»¤æ³¢æ•ˆæœæµ‹è¯•**
   ```bash
   # å¯¹æ¯”æ·»åŠ æ»¤æ³¢å‰åçš„é€Ÿåº¦æ›²çº¿
   rqt_plot /odom/twist/twist/linear/x
   ```

---

## å…«ã€æ€»ç»“

### 8.1 æ‚¨çš„å®ç°ä¼˜åŠ¿ âœ…

1. **æ¶æ„æ¸…æ™°**ï¼šæ§åˆ¶å™¨å’ŒFKåˆ†ç¦»ï¼Œä¾¿äºè°ƒè¯•
2. **æ•°å­¦ä¸¥è°¨**ï¼š4Ã—3æœ€å°äºŒä¹˜FKï¼Œç†è®ºä¸Šæ›´ç²¾ç¡®
3. **åŠŸèƒ½å®Œæ•´**ï¼šæ”¯æŒåŠŸç‡é™åˆ¶ã€åŠ¨æ€å‚æ•°è°ƒæ•´
4. **è°ƒè¯•å‹å¥½**ï¼šå¤§é‡ROS_INFOæ—¥å¿—ï¼Œä¾¿äºé—®é¢˜å®šä½

### 8.2 éœ€è¦æ”¹è¿›çš„åœ°æ–¹ âš ï¸

1. **æ— è¶…æ—¶ä¿æŠ¤** â†’ å¿…é¡»æ·»åŠ ï¼ˆå®‰å…¨å…³é”®ï¼‰
2. **æ— é€Ÿåº¦æ»¤æ³¢** â†’ æ¨èæ·»åŠ ï¼ˆå™ªå£°é—®é¢˜ï¼‰
3. **PIDæ— é™å¹…** â†’ å¿…é¡»æ·»åŠ ï¼ˆç¨³å®šæ€§å…³é”®ï¼‰
4. **æ— é€Ÿåº¦é™åˆ¶** â†’ æ¨èæ·»åŠ ï¼ˆå¹³æ»‘æ€§ï¼‰

### 8.3 ä¸‹ä¸€æ­¥è¡ŒåŠ¨è®¡åˆ’

#### Phase 1: å®‰å…¨åŠ å›ºï¼ˆæœ¬å‘¨ï¼‰
- [x] å›é€€åˆ°åŸºçº¿ç‰ˆæœ¬
- [ ] æ·»åŠ cmd_velè¶…æ—¶ä¿æŠ¤
- [ ] æ·»åŠ PIDè¾“å‡ºé™å¹…
- [ ] æµ‹è¯•åŸºçº¿ç‰ˆæœ¬ç¨³å®šæ€§

#### Phase 2: æ€§èƒ½ä¼˜åŒ–ï¼ˆä¸‹å‘¨ï¼‰
- [ ] æ·»åŠ é€Ÿåº¦æ»¤æ³¢ï¼ˆç§»åŠ¨å¹³å‡ï¼‰
- [ ] è€ƒè™‘ç­‰æ•ˆè½¬å‘è§’ï¼ˆå¯é€‰ï¼‰
- [ ] ä¼˜åŒ–PIDå‚æ•°

#### Phase 3: é«˜çº§åŠŸèƒ½ï¼ˆåç»­ï¼‰
- [ ] æ·»åŠ é€Ÿåº¦é™åˆ¶å™¨
- [ ] æ·»åŠ å¤šç§æ§åˆ¶æ¨¡å¼
- [ ] åŠŸç‡ä¼˜åŒ–æ”¹è¿›

---

## é™„å½•ï¼šå‚è€ƒèµ„æ–™é“¾æ¥

1. **ROS Official Four Wheel Steering Controller**
   - ä»£ç ï¼š`/home/idris/final_ws/src/ros_controllers/four_wheel_steering_controller`
   - æ–‡æ¡£ï¼šhttp://wiki.ros.org/four_wheel_steering_controller

2. **æ‚¨çš„ä¸‰ç¯‡å‚è€ƒæ–‡æ¡£**
   - `ros_controllerä¸­çš„èˆµè½®é‡Œç¨‹è®¡è®¾è®¡.md` - å®˜æ–¹å®ç°è§£æ
   - `å››è½®è½¬å‘è½®å¼é‡Œç¨‹è®¡.md` - Pythonå®ç°å’Œä¸‰ç§æ¨¡å¼
   - `èˆµè½®æ§åˆ¶å™¨å’Œé‡Œç¨‹è®¡æ•°æ®è®¡ç®—.md` - C++å®Œæ•´æ•™ç¨‹

3. **Hero Chassis Controller** (éº¦å…‹çº³å§†è½®ï¼Œä¸é€‚ç”¨)
   - ä»£ç ï¼š`/home/idris/final_ws/reference/hero_chassis_controller`
   - ä»…ä¾›å‚è€ƒåŠŸç‡é™åˆ¶å®ç°

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025-11-29  
**ä½œè€…**: GitHub Copilot  
**çŠ¶æ€**: âœ… åŸºçº¿ç‰ˆæœ¬å·²å›é€€ï¼Œå¾…æ·»åŠ å®‰å…¨åŠ å›º
